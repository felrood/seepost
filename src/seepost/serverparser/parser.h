// Generated by Bisonc++ V3.01.00 on Fri, 02 Mar 2012 14:04:28 +0100

#ifndef Parser_h_included
#define Parser_h_included

// $insert baseclass
#include "parserbase.h"
// $insert scanner.h
#include "../serverscanner/scanner.h"
#include "../serverconnection/serverconnection.h"
#include "value.h"

#include <iostream>
#include <string>
#include <cstdlib>

// $insert namespace-open
namespace Server
{

#undef Parser
class Parser: public ParserBase
{
    // $insert scannerobject
    Scanner d_scanner;
    SEEPost::ServerConnection d_conn;
        
    public:
        int parse();
        Parser(std::istream &in, std::ostream &out, SEEPost::ServerConnection &conn);

    private:
	// handling functions
	     void quit(Value const &message);
       void errormsg(Value const &code, Value const &expl);

       void send(Value const &object);

       void peek();
       void peek(Value const &id);
       void drop(Value &id);
       void length();

       void get(Value const &id);
       void put(Value const &id, Value const &blob);
       void del(Value const &id);
       void list();
       
       void encpubkey(Value const &address);
       void signpubkey(Value const &address);
       
       Value word();
       Value &prepend(Value const &a, Value &b);
       Value &envelope(Value &recipient, Value const &blob);
       Value hex();
       Value string();
       Value blob();
	// end of handling functions

        void error(char * const msg);  // called on (syntax) errors
        int lex();                      // returns the next token from the
                                        // lexical scanner. 
        void print();                   // use, e.g., d_token, d_loc

    // support functions for parse():
        void executeAction(int ruleNr);
        void errorRecovery();
        int lookup(bool recovery);
        void nextToken();
        void print__();
};

inline Parser::Parser(std::istream &in, std::ostream &out, SEEPost::ServerConnection &conn)
: d_scanner(in, out), d_conn(conn)
{ }

inline void Parser::errormsg(Value const &code, Value const &expl)
{
  d_conn.writemsg("OK\n");

  if(code.d_type != Value::STRING || expl.d_type != Value::STRING)
  {
    d_scanner.out2() << "ERROR X-666 Undefined error";
  }
  else
  {
    d_scanner.out2() << "ERROR " << code.d_string << " " << expl.d_string;
  }
  ABORT();
}

inline void Parser::error(char * const msg) {
    std::ostringstream st;
    st << "ERROR X-100 Parser error: " << msg << '\n';
    d_conn.writemsg(st.str());
    ABORT();
}

// $insert lex
inline int Parser::lex()
{
    return d_scanner.lex();
}

inline void Parser::print()       
{
    print__();           // displays tokens if --print was specified
}

inline void Parser::quit(Server::Value const &msg) {
  d_conn.writemsg("QUIT bye\n");
  d_scanner.out2() << "quit";
}

inline void Parser::send(Server::Value const &object){
    
    if(object.d_type != Value::ENVELOPE) {
      d_conn.writemsg("ERROR X-101 Invalid call\n");
      return;
    }

    d_conn.send(object.d_string, object.d_msg);
}

inline void Parser::peek() {
    d_conn.peek();
}

inline void Parser::peek(Server::Value const &id) {
    if(id.d_type != Value::ID) {
      d_conn.writemsg("ERROR X-101 Invalid call\n");
    }
    d_conn.peek(id.d_idx);
}

inline void Parser::drop(Server::Value &id) {
  if(id.d_type != Value::ID) {
    d_conn.writemsg("ERROR X-101 Invalid call\n");
    return;
  }
  d_conn.drop(id.d_idx);
}

inline void Parser::length() {
  d_conn.length();
}

inline Value &Parser::envelope(Server::Value &recipient, Server::Value const &blob) {
  recipient.d_type = Value::ENVELOPE;
  recipient.d_msg = blob.d_string;
  return recipient;
}

inline Value &Parser::prepend(Server::Value const &a, Server::Value &b) {
  b.d_string += " ";
  b.d_string += a.d_string;
  return b;
}

inline Value Parser::word() {
  Value v;
  v.d_type = Value::STRING;
  v.d_string = d_scanner.matched();
  return v;
}

inline void Parser::get(Value const &id) {
  if(id.d_type != Value::ID) {
    d_conn.writemsg("ERROR X-101 Invalid call\n");
    return;
  }
  d_conn.get(id.d_idx);
}

inline void Parser::put(Value const &id, Value const &blob) {
  if(id.d_type != Value::ID || blob.d_type != Value::BLOB) {
    d_conn.writemsg("ERROR X-101 Invalid call\n");
    return;
  }
  d_conn.put(id.d_idx, blob.d_string);
}

inline void Parser::del(Value const &id) {
  if(id.d_type != Value::ID) {
    d_conn.writemsg("ERROR X-101 Invalid call\n");
    return;
  }
  d_conn.del(id.d_idx);
}

inline void Parser::list() {
  d_conn.list();
}

inline void Parser::encpubkey(Value const &address) {
	if(address.d_type != Value::STRING) {
	    d_conn.writemsg("ERROR X-101 Invalid call\n");
	    return;
	}
	d_conn.encpubkey(address.d_string);
}

inline void Parser::signpubkey(Value const &address) {
	if(address.d_type != Value::STRING) {
	    d_conn.writemsg("ERROR X-101 Invalid call\n");
	    return;
	}
	d_conn.signpubkey(address.d_string);
}

inline Value Parser::hex() {
  Value v;
  v.d_type = Value::ID;
  char const *begin = d_scanner.matched().c_str();
  char *end=0;
  v.d_idx = (size_t)strtol(begin, &end, 16);
  return v;
}

inline Value Parser::blob() {
  Value v;
  v.d_type = Value::BLOB;
  v.d_string = d_scanner.matched();
  v.d_string = v.d_string.substr(1);
  v.d_string = v.d_string.substr(0, v.d_string.length() - 1);
  return v;
}

inline Value Parser::string() {
  Value v;
  v.d_type = Value::STRING;
  v.d_string = d_scanner.matched();
  return v;
}


// $insert namespace-close
}

#endif
